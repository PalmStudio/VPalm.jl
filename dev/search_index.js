var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = VPalm","category":"page"},{"location":"#VPalm","page":"Home","title":"VPalm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for VPalm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install VPalm using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/PalmStudio/VPalm.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make a 3D palm using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using VPalm # Import the package\n\n# Import the example parameters:\nparameters = read_parameters(joinpath(vpalm_test_files, \"parameter_file.yml\"), verbose=false)\n\n# Build the 3D mockup:\npalm = build_mockup(parameters)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use PlantGeom and a Makie backend to visualize the palm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantGeom, CairoMakie\nviz(palm)","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [VPalm]","category":"page"},{"location":"#VPalm.add_leaflet_geometry!-NTuple{8, Any}","page":"Home","title":"VPalm.add_leaflet_geometry!","text":"add_leaflet_geometry!(\n    leaflet_node, \n    rachis_position, \n    rachis_orientation, \n    rachis_rotation, \n    stem_bending, \n    refmesh_plane\n)\n\nCreate the leaflet geometry based on its segments.\n\nArguments\n\nleaflet_node: The MTG node of the leaflet\nrachis_position: Position of the rachis section where the leaflet is attached\nrachis_orientation: Orientation angles [zenithal, azimuthal, torsion] of the rachis section\nrachis_rotation: Rotation of the rachis due to phyllotaxy (radians)\nstem_bending: Bending of the stem (radians)\nrefmesh_plane: Reference mesh used for the planar leaflet segments\n\nReturns\n\nNothing (the geometry is added directly to the leaflet node and its segments)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.add_section_geometry!","page":"Home","title":"VPalm.add_section_geometry!","text":"add_section_geometry!(\n    node, internode_width, internode_height, internode_phyllotaxy, stem_bending, \n    refmesh_cylinder, position_section=Ref(Meshes.Point(0.0, 0.0, 0.0)), angles=[0.0, 0.0, 0.0],\n    type::String,\n)\n\nCreate the petiole/rachis sections geometry based on their dimensions.\n\nArguments\n\nnode: the MTG node of the petiole/rachis\nrefmesh_cylinder: the reference mesh used for a cylinder (PlantGeom.RefMesh)\ninternode_width: the width of the internode on the stipe (m)\ninternode_height: the height of the internode on the stipe (m)\ninternode_phyllotaxy: the phyllotaxy of the internode on the stipe (°)\nstem_bending: the bending of the stipe (°)\ntype::String: the type of the section (\"PetioleSegment\" or \"RachisSegment\")\nposition_section=Ref(Meshes.Point(0.0, 0.0, 0.0)): the position of the section relative to the first one.\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.bend-NTuple{16, Any}","page":"Home","title":"VPalm.bend","text":"bend(\n    type, width_bend, height_bend, init_torsion, x, y, z, mass_rachis, mass_leaflets_right, mass_leaflets_left,\n    distance_application, elastic_modulus, shear_modulus, step, npoints, nsegments;\n    all_points=false,\n    angle_max=deg2rad(21),\n    force=true,\n    verbose=true\n)\n\nCompute the deformation of the rachis by applying both bending and torsion.\n\nArguments\n\ntype: Vector of section types (1: triangle bottom, 2: rectangle, 3: triangle top, 4: ellipse, 5: circle).\nwidth_bend: Vector of segment section widths (m).\nheight_bend: Vector of segment section heights (m).\ninit_torsion: Vector of initial torsion angles (degrees).\nx: Vector of x coordinates of the segments.\ny: Vector of y coordinates of the segments.\nz: Vector of z coordinates of the segments.\nmass_rachis: Vector of rachis segment masses (kg).\nmass_leaflets_right: Vector of leaflet masses carried by the segment, on the right side (kg).\nmass_leaflets_left: Vector of leaflet masses carried by the segment, on the left side (kg).\ndistance_application: Vector of application distances for the left and right weights (m).\nelastic_modulus: Vector of elasticity moduli (bending, MPa).\nshear_modulus: Vector of shear moduli (torsion, MPa).\nstep: Length of the segments that discretize the object (m).\nnpoints: Number of points used in the grid discretizing the section.\nnsegments: Number of segments dividing the rachis to compute the torsion and bending.\nall_points=false: return all points used in the computation (true), or only the input points corresponding to x, y and z coordinates (false, default).\nangle_max=deg2rad(21): Maximum angle for testing the small displacement hypothesis (radians).\nforce=true: Check if verify the small displacements hypothesis and bounds the values to be at maximum angle_max\nverbose=true: Provide information during computation.\n\nReturns\n\nNamed tuple with geometrical fields describing the rachis bended and with torsion applied\n\nx: x coordinates of the points.\ny: y coordinates of the points.\nz: z coordinates of the points.\nlength: length of the segments.\nangle_xy: angle between the xy-plan and the segment.\nangle_xz: angle between the xz-plan and the segment.\ntorsion: torsion angle of the segment.\n\nAll these fields are vectors of the same length as the input vectors (i.e. number of segments).\n\nDetails\n\nThe bending and torsion are applied to the sections of the rachis defined by 5 segments.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.beta_distribution_norm-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.beta_distribution_norm","text":"beta_distribution_norm(x, xm, ym)\n\nCalculate the normalized beta distribution value at point x. This is the exact implementation from the Java version.\n\nArguments\n\nx: Position [0 to 1].\nxm: Mode of the beta distribution.\nym: Maximum value of the beta distribution.\n\nReturns\n\nNormalized beta distribution value.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.beta_distribution_norm_integral-Tuple{Any, Any}","page":"Home","title":"VPalm.beta_distribution_norm_integral","text":"beta_distribution_norm_integral(xm, ym)\n\nCalculate the integral (area) of the normalized beta distribution. Equivalent to betaDistributionNormIntegral in the Java version.\n\nArguments\n\nxm: Mode of the beta distribution.\nym: Value of the function at the mode.\n\nReturns\n\nApproximate area under the beta distribution curve.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.biomechanical_properties_rachis-NTuple{21, Any}","page":"Home","title":"VPalm.biomechanical_properties_rachis","text":"biomechanical_properties_rachis(\n    rachis_twist_initial_angle, rachis_twist_initial_angle_sdp,\n    elastic_modulus, shear_modulus, rachis_length,\n    leaflet_length_at_b_intercept, leaflet_length_at_b_slope, relative_position_bpoint,\n    relative_position_bpoint_sd, relative_length_first_leaflet, relative_length_last_leaflet, relative_position_leaflet_max_length,\n    rachis_fresh_weight, rank, height_cpoint, zenithal_cpoint_angle, nb_sections,\n    height_rachis_tappering,\n    points, iterations, angle_max;\n    verbose, rng\n)\n\nUse of the biomechanical model to compute the properties of the rachis.\n\nArguments\n\nrachis_twist_initial_angle: initial twist angle of the rachis (°)\nrachis_twist_initial_angle_sdp: standard deviation of the initial twist angle of the rachis (°)\nelastic_modulus: elastic modulus of the rachis (Pa)\nshear_modulus: shear modulus of the rachis (Pa)\nrachis_length: length of the rachis (m)\nleaflet_length_at_b_intercept: intercept of the linear function for the leaflet length at the B point (m)\nleaflet_length_at_b_slope: slope of the linear function for the leaflet length at the B point (m)\nrelative_position_bpoint: relative position of the B point on the rachis (0: base to 1: tip)\nrelative_position_bpoint_sd: standard deviation of the relative position of the B point on the rachis\nrelative_length_first_leaflet: relative length of the first leaflet on the rachis (0 to 1)\nrelative_length_last_leaflet: relative length of the last leaflet on the rachis (0 to 1)\nrelative_position_leaflet_max_length: relative position of the longest leaflet on the rachis (0.111 to 0.999)\nrachis_fresh_weight: fresh weight of the rachis (kg)\nrank: rank of the rachis\nheight_cpoint: height of the C point (m)\nzenithal_cpoint_angle: zenithal angle of the C point (°)\nnb_sections: number of sections to compute the bending\nheight_rachis_tappering: tappering factor for the rachis height\nnpoints_computed: number of points to compute the bending\niterations: number of iterations to compute the bending\nangle_max: maximum angle to compute the bending (°)\nverbose: display information about the computation (e.g. checks on the units)\nrng: the random number generator\n\nReturns\n\nA named tuple with the following fields:\n\nlength: vector with the length of each segment\npoints_positions: the position of the points along the rachis\nbending: the bending angle of the rachis\ndeviation: the deviation of the rachis (angle in the xz plane)\ntorsion: the torsion of the rachis\nx: the x coordinates of the rachis\ny: the y coordinates of the rachis\nz: the z coordinates of the rachis\n\nDetails\n\nSplit the rachis into 5 segments defined by remarkable points (C, C-B, B, B-A, A). Each segment has a particular shape, a mass, and the leaflets on both sides of the rachis have a mass. Coefficents are used to compute the mass distribution and relative lengths of segments. The rachis is bent using the bend function.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.c_point_angle-NTuple{4, Any}","page":"Home","title":"VPalm.c_point_angle","text":"c_point_angle(leaf_rank, cpoint_decli_intercept, cpoint_decli_slope, cpoint_angle_SDP; rng)\n\nCompute the angle at the C point of the leaf.\n\nArguments\n\nleaf_rank: Rank of the leaf\ncpoint_decli_intercept: Intercept of the linear relationship between leaf rank and C point declination\ncpoint_decli_slope: Slope of the linear relationship\ncpoint_angle_SDP: Standard deviation of the C point angle\nrng: Random number generator\n\nReturns\n\nThe zenithal angle at the C point of the leaf (°)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.calculate_segment","page":"Home","title":"VPalm.calculate_segment","text":"calculate_segment(relative_position, num_segments=10)\n\nCalculate the segment index for a given relative position along the rachis.\n\nArguments\n\nrelative_position: Relative position along the rachis [0 to 1), where 0 is the base and 1 is the tip.\nnum_segments: Number of segments the rachis is divided into (default: 10).\n\nDetails\n\nWe divide the rachis into segments to capture variations in properties along its length. This function:\n\nConverts a continuous relative position (0-1) into a discrete segment index\nEnsures the segment index is within valid bounds (1 to num_segments)\n\nBiological Context\n\nThe palm rachis exhibits changing properties along its length, including:\n\nLeaflet grouping patterns\nLeaflet sizes and angles\n\nDividing the rachis into discrete segments allows the model to represent these gradual changes in a computationally efficient manner. Each segment can have different parameter values that together create the characteristic patterns seen in real palms.\n\nReturns\n\nThe segment index (starts at 1 in Julia).\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.calculate_segment_angles-NTuple{5, Any}","page":"Home","title":"VPalm.calculate_segment_angles","text":"calculate_segment_angles(young_modulus, initial_angle, leaflet_length, tapering, segment_positions)\n\nCalculate the global angles for each segment of a bent leaflet based on the Young's modulus model.\n\nArguments\n\nyoung_modulus: Value of Young's modulus\ninitial_angle: Initial angle from vertical in radians\nleaflet_length: Total length of the leaflet\ntapering: Tapering factor\nsegment_positions: Array of segment boundary positions (normalized 0-1)\n\nReturns\n\nArray of segment angles in radians\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.compute_leaf_rank-Tuple{Any, Any}","page":"Home","title":"VPalm.compute_leaf_rank","text":"compute_leaf_rank(nb_internodes, index_leaf)\n\nCompute the rank of a leaf based on the total number of internodes and the index of the leaf.\n\nArguments\n\nnb_internodes: The total number of internodes until leaf of rank 1.\nindex_leaf: The index of the leaf.\n\nNote\n\nThis is a simple leaf rank, not considering the leaves of rank <= 0.\n\nReturns\n\nThe leaf rank, i.e. 1 for the first opened leaf, 2 for the second leaf, etc.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.compute_leaflet_type_frequencies-Tuple{Any, Any}","page":"Home","title":"VPalm.compute_leaflet_type_frequencies","text":"compute_leaflet_type_frequencies(leaflet_frequency_high, leaflet_frequency_low)\n\nCompute the frequency of leaflet type within the sub-sections of a rachis.\n\nArguments\n\nleaflet_frequency_high: Vector of frequency values for the +1 leaflet types (high) along the rachis sub-sections.\nleaflet_frequency_low: Vector of frequency values for the -1 leaflet types (low) along the rachis sub-sections..\n\nNote that the length of the two vectors must be the same. It will define how many sub-sections the rachis is divided into for this computation.\n\nReturns\n\nA vector of NamedTuples representing the (;high, medium, low) frequencies for each sub-section.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.compute_number_of_leaflets-NTuple{6, Any}","page":"Home","title":"VPalm.compute_number_of_leaflets","text":"compute_number_of_leaflets(rachis_final_length, nb_max, nb_slope, nb_infl, nbLeaflets_SDP; rng)\n\nCompute the number of leaflets based on the logistic function, a standard deviation and a minimum value allowed.\n\nArguments\n\nrachis_final_length: Final length of the rachis (m).\nnb_max: Maximum number of leaflets.\nnb_min: Minimum number of leaflets.\nnb_slope: Slope parameter for the logistic function (leaflet m⁻¹).\nnb_infl: Inflection point parameter for the logistic function (m).\nnbLeaflets_SDP: Standard deviation of the normal distribution for the number of leaflets.\nrng: Random number generator.\n\nReturns\n\nThe computed number of leaflets (integer).\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.compute_properties_internode!-NTuple{8, Any}","page":"Home","title":"VPalm.compute_properties_internode!","text":"compute_properties_internode!(node, index, nb_internodes, nb_leaves_alive, stem_height, stem_diameter, parameters, rng)\n\nComputes the mtg properties of an internode.\n\nArguments\n\nnode: the internode node\nindex: the index of the internode\nnb_internodes: the total number of internodes\n\nNot used ! Confirm and update code !!! - nb_leaves_alive: the number of leaves currently alive\n\nstem_height: the height of the stem (m)\nstem_diameter: the diameter of the stem (m)\nparameters: the parameters of the model\nrng: the random number generator\n\nReturns\n\nThe internode node updated with properties.\n\nDetails\n\nThe internode dimensions are computed based on the dimensions of the stem and the parameters of the model:\n\nwidth: width of the internode (m)\ndiameter: diameter of the internode (m)\nlength: length of the internode (m)\nrank: rank of the internode\nOrthotropy: orthotropy of the internode (set as a constant value)\nXEuler: Euler / phyllotactic angle of the internode (rad)\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(VPalm))), \"test\", \"files\", \"parameter_file.yml\")\nparameters = read_parameters(file)\nnb_internodes = parameters[\"nb_leaves_emitted\"] + parameters[\"nb_internodes_before_planting\"] # The number of internodes emitted since the seed\nnb_leaves_alive = floor(Int, mean_and_sd(parameters[\"nb_leaves_mean\"], parameters[\"nb_leaves_sd\"]; rng=rng))\nnb_leaves_alive = min(nb_leaves_alive, nb_internodes)\n# Plant / Scale 1\nplant = Node(MutableNodeMTG(\"/\", \"Plant\", 1, 1))\n# Stem (& Roots) / Scale 2\nstem = Node(plant, MutableNodeMTG(\"+\", \"Stem\", 1, 2))\ncompute_properties_stem!(stem, parameters, rng)\nstem_height = stem[:stem_height]\nstem_diameter = stem[:stem_diameter]\n# Phytomer / Scale 3\nphytomer = Node(stem, MutableNodeMTG(\"/\", \"Phytomer\", 1, 3))\n# Internode & Leaf / Scale 4\ninternode = Node(phytomer, MutableNodeMTG(\"/\", \"Internode\", 1, 4))\ncompute_properties_internode!(internode, 1, nb_internodes, nb_leaves_alive, stem_height, stem_diameter, parameters, rng)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.compute_properties_leaf!-NTuple{5, Any}","page":"Home","title":"VPalm.compute_properties_leaf!","text":"compute_properties_leaf!(node, index, nb_internodes, nb_leaves_alive, parameters, rng)\n\nCompute the properties of a leaf node:\n\nzenithalinsertionangle: the zenithal insertion angle of the leaf (rad)\nrachis_length: the length of the rachis (m)\nzenithalcpointangle: the zenithal angle at C-point (rad)\n\nArguments\n\nnode: the leaf node\nleaf_rank: the rank of the leaf\nis_alive: is the leaf alive or dead (snag)?\nparameters: the parameters of the model\nrng: the random number generator\n\nReturns\n\nThe leaf node updated with properties.\n\nDetails\n\nThe leaf dimensions are computed based on the dimensions of the stem and the parameters of the model:\n\nzenithalinsertionangle: the zenithal insertion angle of the leaf (rad). Uses the VPalm.leaf_insertion_angle function.\nrachislength: the length of the rachis (m). Uses the `rachisexpansion` function.\nzenithalcpointangle: the zenithal angle at C-point (rad). Uses the c_point_angle function.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(VPalm))), \"test\", \"files\", \"parameter_file.yml\")\nparameters = read_parameters(file)\nnb_internodes = parameters[\"nb_leaves_emitted\"] + parameters[\"nb_internodes_before_planting\"] # The number of internodes emitted since the seed\nnb_leaves_alive = floor(Int, mean_and_sd(parameters[\"nb_leaves_mean\"], parameters[\"nb_leaves_sd\"]; rng=rng))\nnb_leaves_alive = min(nb_leaves_alive, nb_internodes)\n# Plant / Scale 1\nplant = Node(MutableNodeMTG(\"/\", \"Plant\", 1, 1))\n# Stem (& Roots) / Scale 2\nstem = Node(plant, MutableNodeMTG(\"+\", \"Stem\", 1, 2))\ncompute_properties_stem!(stem, parameters, rng)\nstem_height = stem[:stem_height]\nstem_diameter = stem[:stem_diameter]\n# Phytomer / Scale 3\nphytomer = Node(stem, MutableNodeMTG(\"/\", \"Phytomer\", 1, 3))\n# Internode & Leaf / Scale 4\ninternode = Node(phytomer, MutableNodeMTG(\"/\", \"Internode\", 1, 4))\nleaf = Node(internode, MutableNodeMTG(\"+\", \"Leaf\", 1, 4))\ncompute_properties_leaf!(leaf, 1, nb_internodes, nb_leaves_alive, parameters, rng)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.compute_properties_petiole!-NTuple{12, Any}","page":"Home","title":"VPalm.compute_properties_petiole!","text":"compute_properties_petiole!(\n    petiole_node,\n    insertion_angle, rachis_length, zenithal_cpoint_angle,\n    width_base, height_base, cpoint_width_intercept,\n    cpoint_width_slope, cpoint_height_width_ratio,\n    petiole_rachis_ratio_mean,\n    petiole_rachis_ratio_sd, nb_sections;\n    rng=Random.MersenneTwister(1)\n)\n\nCompute the dimensional properties of a petiole.\n\nArguments\n\npetiole_node: the MTG Node of the petiole\ninsertion_angle: the angle of insertion of the petiole on the stem (°)\nrachis_length: the length of the rachis (m)\nzenithal_cpoint_angle: the zenithal angle of the C point of the petiole, i.e. the tip (°)\nwidth_base: the width of the petiole at its base (m)\nheight_base: the height of the petiole at its base (m)\ncpoint_width_intercept: the intercept of the linear function for the width at the C point (m)\ncpoint_width_slope: the slope of the linear function for the width at the C point\ncpoint_height_width_ratio: the ratio of the height to width at the C point\npetiole_rachis_ratio_mean: the mean ratio of the petiole to rachis length\npetiole_rachis_ratio_sd: the standard deviation of the ratio of the petiole to rachis length\nnb_sections: the number of sections discretizing the petiole\nrng=Random.MersenneTwister(1): the random number generator\n\nReturns\n\nThe petiole node updated with properties.\n\nDetails\n\nProperties are computed based on the allometries of the petiole and the rachis:\n\nlength: the length of the petiole (m)\nazimuthal_angle: the azimuthal angle of the petiole (°)\nwidth_base: the width of the petiole at its base (m)\nheight_base: the height of the petiole at its base (m)\nwidth_cpoint: the width of the petiole at the C point (m)\nheight_cpoint: the height of the petiole at the C point (m)\nzenithalinsertionangle: the zenithal angle of insertion of the petiole on the stem (°)\nzenithalcpointangle: the zenithal angle of the C point of the petiole (°)\nsection_length: the length of the petiole sections (m)\nsectioninsertionangle: the zenithal angle of insertion between the petioles sections (°)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.compute_properties_petiole_section!-NTuple{5, Any}","page":"Home","title":"VPalm.compute_properties_petiole_section!","text":"compute_properties_petiole_section!(petiole_node, section_node, index, nb_sections)\n\nCompute the dimension of a petiole section based on the dimensions of the petiole.\n\nArguments\n\npetiole_node: the MTG Node of the petiole\nsection_node: the MTG Node of the section to be computed\nindex: the index of the section on the petiole, from 1 at the base to nb_sections.\nnb_sections: the number of sections discretizing the petiole\nsection_insertion_angle: the zenithal angle of the petioles sections (global angle, °)\n\nReturns\n\nThe section node updated with dimensional properties.\n\nDetails\n\nThe petiole_node should have the following attributes:\n\nwidth_base: the width of the petiole at its base (m)\nheight_base: the height of the petiole at its base (m)\nwidth_cpoint: the width of the petiole at the C point (m)\nheight_cpoint: the height of the petiole at the C point (m)\nsection_length: the length of the petiole sections (m)\ninsertion_angle: the angle of insertion of the petiole on the stem (°)\nsection_insertion_angle: the zenithal angle of insertion between the petioles sections (°)\nazimuthal_angle: the azimuthal angle at the insertion (°)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.compute_properties_stem!-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.compute_properties_stem!","text":"compute_properties_stem!(node, parameters, rng)\n\nCompute the properties of the stem node.\n\nArguments\n\nnode: the stem node\nparameters: the parameters of the Vpalm model\nrng: the random number generator\n\nReturns\n\nThe stem node updated with properties.\n\nDetails\n\nThe stem dimensions are computed based on the parameters of the model:\n\nstembending: the bending of the stem. Uses the `VPalm.stembending` function.\nstemheight: the height of the stem. Uses the `VPalm.stemheight` function.\nstemdiameter: the diameter of the stem. Uses the `VPalm.stemdiameter` function.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(VPalm))), \"test\", \"files\", \"parameter_file.yml\")\nparameters = read_parameters(file)\nnb_internodes = parameters[\"nb_leaves_emitted\"] + parameters[\"nb_internodes_before_planting\"] # The number of internodes emitted since the seed\nnb_leaves_alive = floor(Int, mean_and_sd(parameters[\"nb_leaves_mean\"], parameters[\"nb_leaves_sd\"]; rng=rng))\nnb_leaves_alive = min(nb_leaves_alive, nb_internodes)\n# Plant / Scale 1\nplant = Node(MutableNodeMTG(\"/\", \"Plant\", 1, 1))\n# Stem (& Roots) / Scale 2\nstem = Node(plant, MutableNodeMTG(\"+\", \"Stem\", 1, 2))\ncompute_properties_stem!(stem, parameters, rng)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.create_leaflet_segments!-NTuple{9, Any}","page":"Home","title":"VPalm.create_leaflet_segments!","text":"create_leaflet_segments!(\n    unique_mtg_id,\n    leaflet_node,\n    scale,\n    leaflet_length,\n    width_max,\n    stiffness,\n    tapering,\n    leaflet_relative_pos,\n    parameters\n)\n\nCreate the segments that make up a leaflet with proper shape and bending properties.\n\nArguments\n\nunique_mtg_id: Reference to the unique ID counter\nleaflet_node: Parent leaflet node\nscale: MTG scale for the segments\nleaflet_length: Total length of the leaflet in meters\nwidth_max: Maximum width of the leaflet in meters\nstiffness: Stiffness value (Young's modulus) for biomechanical bending\ntapering: Tapering factor (how width decreases along length)\nleaflet_relative_pos: Relative position of the leaflet on the rachis (0-1)\nparameters: Model parameters\n\nReturns\n\nNothing (segments are added directly to the leaflet node as children)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.create_leaflets_for_side!-NTuple{12, Any}","page":"Home","title":"VPalm.create_leaflets_for_side!","text":"create_leaflets_for_side!(\n    unique_mtg_id,\n    rachis_node,\n    scale,\n    leaf_rank,\n    rachis_length,\n    nb_rachis_sections,\n    leaflets_position,\n    leaflets,\n    leaflet_max_length,\n    leaflet_max_width,\n    side,\n    parameters;\n    last_rank_unfolding=2,\n    rng=Random.MersenneTwister(1234)\n)\n\nCreate leaflets for one side of the palm frond rachis.\n\nArguments\n\nunique_mtg_id: Reference to the unique ID counter for MTG nodes\nrachis_node: Root node of the rachis\nscale: MTG scale for leaflets\nleaf_rank: Rank of the leaf (affects unfolding for young fronds)\nrachis_length: Total length of the rachis in meters\nnb_rachis_sections: Number of segments dividing the rachis\nleaflets_position: Array of positions along the rachis for each leaflet\nleaflets: NamedTuple with leaflet grouping information (group, group_size, plane)\nleaflet_max_length: Maximum length of leaflets (length of the longest leaflet)\nleaflet_max_width: Maximum width of leaflets (width of the widest leaflet)\nside: Side of rachis (1=right, -1=left)\nparameters: Model parameters\nlast_rank_unfolding=2: Rank at which leaflets are fully unfolded (default is 2)\nrng=Random.MersenneTwister(1234): Random number generator\n\nReturns\n\nNothing (leaflets are attached directly to the rachis node in the MTG structure)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.create_section-Tuple{Any, Any}","page":"Home","title":"VPalm.create_section","text":"create_section(section, section_type)\n\nFill in the matrix according to the section shape.\n\nArguments\n\nsection: Section matrix.\nsection_type: Section type (1: triangle bottom, 2: rectangle, 3: triangle top, 4: ellipse, 5: circle).\n\nReturns\n\nThe filled section matrix with 1s for cells inside the shape and 0s outside.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.create_single_leaflet-NTuple{11, Any}","page":"Home","title":"VPalm.create_single_leaflet","text":"create_single_leaflet(\n    unique_mtg_id,\n    index,\n    scale,\n    leaf_rank,\n    leaflet_relative_pos,\n    norm_leaflet_rank,\n    plane,\n    side,\n    leaflet_max_length,\n    leaflet_max_width,\n    parameters;\n    offset=0.0,\n    last_rank_unfolding=2,\n    rng=Random.MersenneTwister(1234)\n)\n\nCreate a single leaflet with properly computed angles, dimensions and segments.\n\nArguments\n\nunique_mtg_id: Reference to the unique ID counter\nindex: Index for the leaflet node (for identification in MTG)\nscale: MTG scale level for the leaflet\nleaf_rank: Rank of the leaf (affects unfolding for young leaves)\nleaflet_relative_pos: Relative position of leaflet on rachis (0 to 1)\nnorm_leaflet_rank: Normalized rank of the leaflet (0 to 1)\nplane: Plane type of leaflet (1=high/upward, 0=medium/horizontal, -1=low/downward)\nside: Side of the leaf (1=right, -1=left)\nleaflet_max_length: Maximum leaflet length in meters (length of the longest leaflet)\nleaflet_max_width: Maximum leaflet width in meters (width of the widest leaflet)\nparameters: Model parameters dictionary\noffset: Offset from the start of parent node (when applicable)\nlast_rank_unfolding: Rank at which leaflets are fully unfolded (default is 2)\nrng: Random number generator\n\nReturns\n\nThe created leaflet node with all its segment children\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.cylinder-Tuple{}","page":"Home","title":"VPalm.cylinder","text":"cylinder()\ncylinder(r, l)\n\nReturns a normalized cylinder mesh, or a cylinder with radius r and length l.\n\nArguments\n\nr: The radius of the cylinder.\nl: The length of the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.dist_and_angles_to_xyz-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.dist_and_angles_to_xyz","text":"dist_and_angles_to_xyz(dist_p2p1, vangle_xy, vangle_xz)\n\nTransform distances and angles into point coordinates.\n\nArguments\n\ndist_p2p1: Vector of segment lengths (m).\nvangle_xy: Vector of angles between the segment and the XY plane (radians).\nvangle_xz: Vector of angles between the segment and the XZ plane (radians).\n\nReturns\n\nThe points as a vector of Meshes.Point.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.draw_group_size-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.draw_group_size","text":"draw_group_size(group, leaflet_type_frequencies, rng)\n\nDetermine the size of a leaflet group based on the relative position along the rachis and frequency patterns.\n\nArguments\n\ngroup: Index of the leaflet group based on its relative position on the rachis (1 to length(leaflet_type_frequencies)).\nleaflet_type_frequencies: Vector of NamedTuples representing frequency distributions for each rachis segment, with fields:\nhigh: Frequency of plane=+1 leaflets (first leaflet in each group), i.e. leaflets on \"high\" position\nmedium: Frequency of plane=0 leaflets (intermediate leaflets in groups), i.e. leaflets on \"medium\" position, horizontally inserted on the rachis\nlow: Frequency of plane=-1 leaflets (terminal leaflets in groups), i.e. leaflets on \"low\" position\nrng: Random number generator for stochastic determination.\n\nDetails\n\nThis function implements an inverse relationship between the frequency of high (plane=1) leaflets and group size, modeling a fundamental biological pattern in palm frond architecture:\n\nSegments with high frequency of high leaflets produce many small groups of leaflets\nSegments with low frequency of high leaflets produce fewer, larger groups of leaflets\n\nThe calculation uses a probabilistic rounding mechanism to ensure proper statistical distribution  of group sizes. This creates the natural variation in leaflet grouping patterns seen along real palm fronds, where clustering patterns change systematically from base to tip.\n\nReturns\n\nAn integer representing the number of leaflets in the group.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.elliptical_cylinder-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.elliptical_cylinder","text":"elliptical_cylinder(r1, r2, l)\n\nCreate an elliptical cylinder mesh.\n\nArguments\n\nr1: The radius of the cylinder in the x direction.\nr2: The radius of the cylinder in the y direction.\nl: The length of the cylinder.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.exponetial-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.exponetial","text":"exponetial(x, a, b)\n\nCompute an exponential function at given x value.\n\nArguments\n\nx: The input value.\na: The coefficient a of the exponential function.\nb: The coefficient b of the exponential function.\n\nNote\n\nThe exponential function is defined as a * exp(b * x).\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.final_angle-NTuple{4, Any}","page":"Home","title":"VPalm.final_angle","text":"final_angle(young_modulus, z_angle, length, tapering)\n\nCalculate the maximal deformation angle of a beam.\n\nArguments\n\nyoung_modulus: Value of Young's modulus\nz_angle: Angle from vertical (upright) in radians\nlength: Length of the beam where the load is applied\ntapering: Tapering factor of the beam\n\nReturns\n\nThe final angle from vertical at the cantilever extremity (in radians)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.group_leaflets-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.group_leaflets","text":"group_leaflets(leaflets_relative_position, leaflets_type_frequency, rng)\n\nCompute the group, group size and plane positions of each leaflet along the rachis.\n\nArguments\n\nleaflets_relative_position: Array of relative positions for the leaflets along the rachis (see relative_leaflet_position()).\nleaflets_type_frequency: Vector of NamedTuples representing frequency distributions along the rachis (if e.g. 10 values are provided, it means the rachis is divided into 10 sub-sections), with fields:\nhigh: Frequency of plane=+1 leaflets (first leaflet in each group), i.e. leaflets on \"high\" position\nmedium: Frequency of plane=0 leaflets (intermediate leaflets in groups), i.e. leaflets on \"medium\" position, horizontally inserted on the rachis\nlow: Frequency of plane=-1 leaflets (terminal leaflets in groups), i.e. leaflets on \"low\" position\nrng: Random number generator.\n\nDetails\n\nThis function:\n\n1. Organizes leaflets into groups based on position-dependent size distributions\n2. Assigns a spatial plane to each leaflet within a group:\n    - The first leaflet in each group is always placed on the high position (plane=1)\n    - Subsequent leaflets are positioned on medium (plane=0) or low (plane=-1) positions based on their frequency distribution at that rachis segment\n\nBiological Context\n\nGrouping of leaflets is a key morphological feature in palm species, particularly in oil palm (Elaeis guineensis). Unlike some palms with regularly spaced leaflets, oil palms exhibit distinctive clustering patterns where:\n\nLeaflets occur in groups of variable sizes, but typically around 3 leaflets per group\nWithin each group, leaflets emerge at different angles:\nThe first leaflet points upward (high position)\nOthers point horizontally or downward (medium and low positions)\nThe pattern of grouping changes along the rachis:\nCloser to the base: typically larger groups with more leaflets\nToward the tip: smaller groups or single leaflets\n\nThe model uses an inverse relationship between high-position leaflet frequency and group size to recreate the natural variation in leaflet insertion angle - sections with many high-position leaflets have smaller groups (but more of them), while sections with few high-position leaflets form larger groups.\n\nThe grouping pattern changes along the rachis, creating the characteristic appearance of palm fronds with varying leaflet arrangement  patterns from base to tip.\n\nReturns\n\nA NamedTuple containing arrays for:\n\ngroup: Group identifier for each leaflet\ngroup_size: Size of the group that each leaflet belongs to\nplane: Spatial position/orientation of each leaflet (1=high, 0=medium, -1=low)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.height_to_width_ratio-NTuple{5, Any}","page":"Home","title":"VPalm.height_to_width_ratio","text":"height_to_width_ratio(x, ratio_point_c, ratio_point_a, pos_ratio_max, ratio_max)\n\nComputes the relative width along the rachis.\n\nArguments\n\nx: relative position on the rachis\nratio_point_c: ratio at point C\nratio_point_a: ratio at point A\npos_ratio_max: relative position of the maximum value of the ratio\nratio_max: maximum ratio value\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.inertia_flex_rota","page":"Home","title":"VPalm.inertia_flex_rota","text":"inertia_flex_rota(base_width, height, orientation_angle, section_type, grid_size = 100)\n\nCompute the inertia of bending and torsion, and the cross-section area.\n\nArguments\n\nbase_width: Dimension of the base.\nheight: Dimension of the height.\norientation_angle: Section orientation angle (torsion, in radians).\nsection_type: Section type (see details).\ngrid_size: Number of discretizations (default to 100).\n\nDetails\n\nFor the section type, possible values are:\n\nsection_type = 1: triangle (bottom-oriented)\nsection_type = 2: rectangle\nsection_type = 3: triangle (top-oriented)\nsection_type = 4: ellipse\nsection_type = 5: circle\n\nReturns\n\nA NamedTuple with fields:\nig_flex: Bending inertia.\nig_tor: Torsion inertia.\nsr: Cross-section surface.\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.internode_diameter-NTuple{6, Any}","page":"Home","title":"VPalm.internode_diameter","text":"internode_diameter(internode_index, nb_internodes, stem_diameter, stem_base_shrinkage, stem_top_shrinkage, leaves_in_sheath)\n\nComputes the diameter of an internode at a given rank.\n\nArguments\n\ninternode_index: The index of the internode.\nnb_internodes: The total number of internodes.\nstem_diameter: The diameter of the stem at the base.\nstem_base_shrinkage: The shrinkage coefficient at the stem base.\nstem_top_shrinkage: The shrinkage coefficient at the stem top.\nleaves_in_sheath: The number of leaves in the sheath.\n\nReturns\n\nThe diameter of the internode (m).\n\nDetails\n\nA shrinking function is applied to the stem base and top to compute the diameter of the internode.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.internode_length-NTuple{6, Any}","page":"Home","title":"VPalm.internode_length","text":"Internode length model\n\nComputes the length of an internode at a given rank.\n\nArguments\n\ni/ internode_index: The index of the internode.\nNbl / nb_internodes: The total number of internodes == number of leaves emitted since planting.\nsh / stem_height: The height of the stem.\nR / internode_rank_no_expansion: The rank of the internode that will not expand.\nN / nb_internodes_before_planting: The number of internodes before planting.\nl_0 / internode_min_height: The minimal length of the internode.\n\nReturns\n\nThe length of the internode (m).\n\nDetails\n\nThe internode length is computed using a quadratic function. The objective is to have a internodes that are short and growing for the first emitted leaves (before nb_internodes_before_planting), and then getting to a stable \"constant\" height, and at the end for the youngest leaves, having nodes currently growing (smaller).\n\nThe internode length is computed as follows :   Internode length     ^ l   |      _____________________     |    /|                     ||   / |                     | l0 |  /  |                     |  |-|–-|––––––––––-|–-|––> Internode number       1   N                   N +   N + Nbl        \t\t\t\t\t\t  Nbl -                               R where :     - l0 is internode_min_height (m), the minimum height of the internode.     - l is internode_heigth_final (m), the maximum height of the internode.- N isnbinternodesbeforeplanting, the number of internodes before planting.     - R isinternoderanknoexpansion, the number of internodes not in expansion.     - Nbl is the number of leaves emitted since planting. with the conditions that :     - the sum of the areas of the first triangle, the rectangle and the last triangle is equal tostemheight.     - if the equation of the first line isa * x + b:         -a = (l - l0) / (N - 1)-b = l0 - a- the area of the first triangle isa * N * (N + 1) / 2 + b * Nand after development :l * N/2 + l0 * N/2- the area of the rectangle (between N + 1 and N + Nbl - R - 1) is(Nbl - R - 1) * l- if the equation of the last line isc * x + d, then:         -c = (l0 - l) / R-d = l0 - c * (Nbl + N)- the area of the last triangle is(R + 1) * (c * (2N + 2Nbl - R) / 2 + d)and after development :l * ((R + 1)/ 2) + l_0 * (-(R + 1) / 2 + R + 1)reminder:     - the sum of integers from m to n isn * (n + 1) / 2 - m * (m - 1) / 2- the sum of cx + d from m to n isc * (n * (n + 1) / 2 - m * (m - 1) / 2) + d * (n - m + 1)or(n - m + 1) * (c * (n + m) / 2 + d)`\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.interp_points-Union{Tuple{P}, Tuple{AbstractVector{P}, Any}} where P<:Meshes.Point","page":"Home","title":"VPalm.interp_points","text":"interp_points(points, step)\n\nInterpolate points along a path to have equidistant points.\n\nArguments\n\npoints: Vector of Meshes.Point objects defining the original path.\nstep: Distance between interpolated points.\n\nReturns\n\nvec_points: Vector of interpolated Meshes.Point objects.\ni_discret_pts_exp: Indices of the original points in the interpolated path.\nvec_dist_p2p1: Vector of distances between consecutive points.\nvec_angle_xy: Vector of angles between segments and the XY plane.\nvec_angle_xz: Vector of angles between segments and the XZ plane.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.leaf_insertion_angle","page":"Home","title":"VPalm.leaf_insertion_angle","text":"leaf_insertion_angle(rank, leaf_max_angle=90, leaf_slope_angle=0.05, leaf_inflection_angle=40)\n\nCompute the insertion angle of the leaf on the internode.\n\nNote: The insertion angle is computed using a logistic function.\n\nArguments\n\nrank: The rank of the leaf.\nleaf_max_angle: The maximum angle of the leaf.\nleaf_slope_angle: The slope of the logistic function.\nleaf_inflection_angle: The inflection point of the logistic function.\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.leaflet_azimuthal_angle-NTuple{7, Any}","page":"Home","title":"VPalm.leaflet_azimuthal_angle","text":"leaflet_azimuthal_angle(relative_pos, side, angle_c, angle_slope, angle_a, angle_sdp, rng)\n\nCalculate the leaflet insertion angle in the horizontal plane (in degrees).\n\nArguments\n\nrelative_pos: Relative position of the leaflet on the rachis [0 to 1].\nside: Side of the leaf (1 for right, -1 for left).\nangle_c: Constant parameter for the axial angle calculation (°).\nangle_slope: Slope parameter for the axial angle calculation (°).\nangle_a: Amplitude parameter for the axial angle calculation (°).\nangle_sdp: Standard deviation percentage for random variation (°).\nrng: Random number generator.\n\nReturns\n\nHorizontal insertion angle in degrees.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.leaflet_length_at_bpoint-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.leaflet_length_at_bpoint","text":"leaflet_length_at_bpoint(rachis_length, intercept, slope)\n\nCompute the length of leaflets at the B point of the rachis using a linear relationship.\n\nArguments\n\nrachis_length: The total length of the rachis (m).\nintercept: The intercept parameter of the linear function (m).\nslope: The slope parameter of the linear function (dimensionless).\n\nDetails\n\nThis function uses a linear model to determine leaflet length at the B point:\n\nleaflet_length = intercept + slope * rachis_length\n\nThe B point is a key reference point on the rachis that marks the transition from an oval to a round shape of the  rachis. The leaflet length at this point serves as a reference for calculating the distribution of leaflet lengths  along the entire rachis.\n\nReturns\n\nThe length of leaflets at the B point position (m).\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.leaflet_length_max-NTuple{7, Any}","page":"Home","title":"VPalm.leaflet_length_max","text":"leaflet_length_max(\n    leaflet_length_at_b, \n    relative_position_bpoint, \n    relative_length_first_leaflet, \n    relative_length_last_leaflet, \n    relative_position_leaflet_max_length, \n    relative_position_bpoint_sd, \n    rng\n)\n\nCalculate the maximum leaflet length for the rachis, used to scale the relative length profile.\n\nArguments\n\nleaflet_length_at_b: Length of leaflets at the B point on the rachis (m).\nrelative_position_bpoint: Relative position of the B point along the rachis (0 to 1).\nrelative_length_first_leaflet: Relative length of the first leaflet at rachis base [0 to 1].\nrelative_length_last_leaflet: Relative length of the last leaflet at rachis tip [0 to 1].\nrelative_position_leaflet_max_length: Relative position where leaflets reach maximum length [0 to 1].\nrelative_position_bpoint_sd: Standard deviation for stochastic variation in B point position.\nrng: Random number generator.\n\nDetails\n\nThis function calculates the maximum leaflet length that would result in the specified  leaflet length at the B point, considering the shape of the length profile along the rachis.\n\nThe calculation uses the inverse of the relative length function at the B point position  to determine what maximum value would yield the desired length at that specific position.\n\nBiological Context\n\nIn palm fronds, leaflet length typically follows a bell-shaped distribution along the rachis:\n\nLeaflets are short at the base (petiole end)\nThey increase in length to reach a maximum somewhere close to the middle of the rachis\nThey decrease in length toward the tip\n\nThe B point is a key morphological reference point where the rachis cross-section  transitions from oval to round. By knowing the leaflet length at this specific point, we can calculate the maximum leaflet length for the entire frond, which serves as a scaling factor for all other leaflets.\n\nThe stochastic variation in B point position reflects natural biological variability between individual palms or fronds.\n\nReturns\n\nThe maximum leaflet length for the rachis (m).\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.leaflet_width_at_bpoint-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.leaflet_width_at_bpoint","text":"leaflet_width_at_bpoint(rachis_length, intercept, slope)\n\nCalculate leaflet width at B point (reference point).\n\nArguments\n\nrachis_length: The total length of the rachis (m).\nintercept: The intercept parameter of the linear function (m).\nslope: The slope parameter of the linear function (dimensionless).\n\nDetails\n\nThis function uses a linear model to determine leaflet width at the B point:\n\nleaflet_width = intercept + slope * rachis_length\n\nThe B point is a key reference point on the rachis that marks the transition  between different architectural zones. The leaflet width at this point serves  as a reference for calculating the distribution of leaflet widths along the  entire rachis.\n\nReturns\n\nThe width of leaflets at the B point position (m).\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.leaflet_width_max-NTuple{7, Any}","page":"Home","title":"VPalm.leaflet_width_max","text":"leaflet_width_max(\n    leaflet_width_at_b,\n    relative_position_bpoint,\n    width_first,\n    width_last,\n    pos_width_max,\n    relative_position_bpoint_sd,\n    rng\n)\n\nleaflet_width_max(\n    leaflet_width_at_b,\n    relative_position_bpoint,\n    width_first,\n    width_last,\n    pos_width_max,\n)\n\nCalculate the maximum leaflet width for the rachis, used to scale the width profile.\n\nArguments\n\nleaflet_width_at_b: Width of leaflets at the B point on the rachis (m).\nrelative_position_bpoint: Mean relative position of the B point along the rachis [0 to 1].\nwidth_first: Relative width of the first leaflet at rachis base [0 to 1].\nwidth_last: Relative width of the last leaflet at rachis tip [0 to 1].\npos_width_max: Relative position where leaflets reach maximum width [0 to 1].\nrelative_position_bpoint_sd: Standard deviation for stochastic variation in B point position (optional).\nrng: Random number generator (optional). \n\nDetails\n\nThis function calculates the maximum leaflet width that would result in the specified  width at the B point, considering the shape of the width profile along the rachis.\n\nThe calculation uses the inverse of the relative width function at the B point position  to determine what maximum value would yield the desired width at that specific position.\n\nBiological Context\n\nIn palm fronds, leaflet width typically varies along the rachis:\n\nNarrow leaflets at the base (petiole end)\nWider leaflets in the middle region\nNarrowing again toward the tip\n\nBy knowing the leaflet width at the B point, we can calculate the maximum  leaflet width for the entire frond, which serves as a scaling factor for  all other leaflets.\n\nReturns\n\nThe maximum leaflet width for the rachis (m).\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.leaflet_zenithal_angle-NTuple{12, Any}","page":"Home","title":"VPalm.leaflet_zenithal_angle","text":"leaflet_zenithal_angle(relative_pos, leaflet_type, side, high_a0_sup, high_amax_sup, high_a0_inf, high_amax_inf, \n             low_a0_sup, low_amax_sup, low_a0_inf, low_amax_inf, rng)\n\nCalculate the leaflet insertion angle in the vertical plane (in degrees).\n\nArguments\n\nrelative_pos: Relative position of the leaflet on the rachis [0 to 1].\nleaflet_type: Type of leaflet (-1=down, 0=medium, 1=up).\nside: Side of the leaf (1 for right, -1 for left).\nhigh_a0_sup: Upper bound of angle at position 0 for high position leaflets.\nhigh_amax_sup: Upper bound of maximum angle for high position leaflets.\nhigh_a0_inf: Lower bound of angle at position 0 for high position leaflets.\nhigh_amax_inf: Lower bound of maximum angle for high position leaflets.\nlow_a0_sup: Upper bound of angle at position 0 for low position leaflets.\nlow_amax_sup: Upper bound of maximum angle for low position leaflets.\nlow_a0_inf: Lower bound of angle at position 0 for low position leaflets.\nlow_amax_inf: Lower bound of maximum angle for low position leaflets.\nrng: Random number generator.\n\nReturns\n\nVertical insertion angle in degrees.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.leaflet_zenithal_angle_boundaries","page":"Home","title":"VPalm.leaflet_zenithal_angle_boundaries","text":"leaflet_zenithal_angle_boundaries(rel_pos, a0, a_max, xm=0.5)\n\nCalculate the boundaries of the radial angle based on position along the rachis.\n\nArguments\n\nrel_pos: Relative position on the rachis [0 to 1].\na0: Radial angle around C point.\na_max: Maximum value of radial angle (in degrees).\nxm: Relative position on rachis of the maximum radial angle (default: 0.5).\n\nReturns\n\nRadial angle in degrees.\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.linear-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.linear","text":"linear(x, intercept, slope)\n\nCompute a linear function at given x value.\n\nArguments\n\nx: The input value.\nintercept: The intercept of the linear function.\nslope: The slope of the linear function.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.local_flexion-NTuple{5, Any}","page":"Home","title":"VPalm.local_flexion","text":"local_flexion(current_angle, final_angle, young_modulus, tapering, relative_position)\n\nCalculate the local bending angle at a specific position along the beam.\n\nArguments\n\ncurrent_angle: Current angle in radians\nfinal_angle: Final angle of the beam in radians\nyoung_modulus: Value of Young's modulus\ntapering: Tapering factor of the beam\nrelative_position: Relative position along the beam (0 to 1)\n\nReturns\n\nFlexion angle at the current position (in radians)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.logistic-NTuple{4, Any}","page":"Home","title":"VPalm.logistic","text":"logistic(x, max, slope, inflection)\n\nCompute a logistic function.\n\nArguments\n\nx: The input value.\nmax: The maximum value of the logistic function.\nslope: The slope of the logistic function.\ninflection: The inflection point of the logistic function.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.mean_and_sd-Tuple{Any, Any}","page":"Home","title":"VPalm.mean_and_sd","text":"mean_and_sd(mean, sd; rng=Random.MersenneTwister(1234))\n\nCompute a random value from a normal distribution with a given mean and standard deviation.\n\nArguments\n\nmean: The mean of the normal distribution.\nsd: The standard deviation of the normal distribution.\n\nOptional arguments\n\nrng: The random number generator.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.mtg_skeleton-Tuple{Any}","page":"Home","title":"VPalm.mtg_skeleton","text":"mtg_skeleton(nb_internodes)\n\nMakes an MTG skeleton with nb_leaves_emitted leaves, including all intermediate organs:\n\nPlant: the whole palm\nStem: the stem of the plant, i.e. the remaining part of the plant after the leaves have been removed\nPhytomer: the part that includes the leaf and the internode\nInternodes: the part of the phytomer that is between two leaves\nLeaf: the leaf of the plant, also called frond\n\nNote: this skeleton does not include reproductive organs (inflorescences, fruits) or the scales that decompose the leaf (petiole, rachis, leaflets).\n\nArguments\n\nnb_internodes: The number of internodes to emit.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(VPalm))), \"test\", \"files\", \"parameter_file.yml\")\nparameters = read_parameters(file)\nmtg_skeleton(parameters)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.normal_deviation_draw","page":"Home","title":"VPalm.normal_deviation_draw","text":"normal_deviation_draw(sd, rng=Random.MersenneTwister(1234))\n\nDraw a random value from a normal distribution with a given standard deviation.\n\nArguments\n\nsd: The standard deviation of the normal distribution.\n\nOptional arguments\n\nrng: The random number generator.\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.normal_deviation_percent_draw-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.normal_deviation_percent_draw","text":"normal_deviation_percent_draw(value, sdp, rng)\n\nCalculate a normally distributed random deviation based on a percentage of the value.\n\nArguments\n\nvalue: Base value.\nsd: Standard deviation in %.\nrng: Random number generator.\n\nReturns\n\nThe random deviation.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.normalize_positions!-Tuple{Any, Any}","page":"Home","title":"VPalm.normalize_positions!","text":"normalize_positions!(positions, rachis_length)\n\nScale and offset positions to span the full rachis length.\n\nArguments\n\npositions: Vector of positions to be modified in place.\nrachis_length: Total length of rachis in meters.\n\nDetails\n\nThis function:\n\nOffsets positions so the first leaflet is at position 0\nScales all positions to ensure the last leaflet is exactly at rachis_length\nMaintains the relative spacing pattern established by previous processing\n\nThis ensures leaflets are properly distributed along the entire rachis while preserving the characteristic grouping patterns.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.petiole-NTuple{7, Any}","page":"Home","title":"VPalm.petiole","text":"petiole(parent_node, index, scale, rachis_length, zenithal_insertion_angle, zenithal_cpoint_angle, parameters)\n\nMake a leaf petiole.\n\nArguments\n\nunique_mtg_id: a next free unique id for the MTG nodes\nparent_node: the parent node on which the petiole will be attached\nindex: the MTG index of the petiole\nscale: the MTG scale of the petiole\nrachis_length: the rachis length, used to feed allometries to compute the petiole dimensions\nzenithal_insertion_angle: petiole insertion angle\nzenithal_cpoint_angle: angle at the C point (tip of the petiole, starting point of the rachis)\nparameters: a list of parameters as a Dict{String}:\n\"leafbasewidth\": the base width of the petiole (m)\n\"leafbaseheight\": the base heigth of the petiole (m)\n\"cpointwidthintercept\": petiole width at the c-point intercept for linear interpolation (m)\n\"cpointwidthslope\": petiole width at the c-point slope for linear interpolation\n\"cpointheightwidth_ratio\": height to width ratio at the C point\n\"petiolerachisratio_mean\": the average value of the ratio between rachis length and petiole length\n\"petiolerachisratio_sd\": its standard deviation\n\"petiolenbsegments\": the number of segments used to discretize the petiole\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.petiole_azimuthal_angle-Tuple{}","page":"Home","title":"VPalm.petiole_azimuthal_angle","text":"petiole_azimuthal_angle(; rng=Random.MersenneTwister(1))\n\nCompute the azimuthal angle of the petiole based on the petiole/rachis length ratio.\n\nArguments\n\npetiole_rachis_ratio_mean: Average value of the petiole/rachis length ratio\npetiole_rachis_ratio_sd: Standard deviation of the petiole/rachis length ratio\nrng: Random number generator\n\nReturns\n\nThe azimuthal angle of the petiole (°)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.petiole_dimensions_at_cpoint","page":"Home","title":"VPalm.petiole_dimensions_at_cpoint","text":"petiole_dimensions_at_cpoint(rachis_length, cpoint_width_intercept, cpoint_width_slope, cpoint_height_width_ratio)\n\nCompute the width and height of the petiole at the C point (end-point).\n\nArguments\n\nrachis_length: Length of the rachis (m)\ncpoint_width_intercept=0.0098u\"m\": Intercept of the linear relationship between rachis width at C point and rachis length (m)\ncpoint_width_slope=0.012: Slope of the linear relationship\ncpoint_height_width_ratio=0.568: Ratio between the height and width of the leaf at C point\n\nReturns\n\nA named tuple with the following keys:\n\nwidth_cpoint: Width at the C point of the petiole (m)\nheight_cpoint: Height at the C point of the petiole (m)\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.petiole_height-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.petiole_height","text":"petiole_height(relative_position, height_cpoint, height_base)\n\nCompute the height profile along the petiole (m).\n\nArguments\n\nrelative_position: Position along the petiole (0-1)\nheight_base: Height at the base of the leaf\nheight_cpoint: Height of the leaf section at C point\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.petiole_length","page":"Home","title":"VPalm.petiole_length","text":"petiole_length(petiole_rachis_ratio_mean, petiole_rachis_ratio_sd, rachis_length; rng=Random.MersenneTwister(1))\n\nCompute the length of the petiole based on the rachis length and the petiole/rachis length ratio.\n\nArguments\n\nrachis_length: Length of the rachis (m)\npetiole_rachis_ratio_mean=0.25: Average value of the petiole/rachis length ratio\npetiole_rachis_ratio_sd=0.034: Standard deviation of the petiole/rachis length ratio\nrng: Random number generator\n\nReturns\n\nThe length of the petiole (m)\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.petiole_sections!-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.petiole_sections!","text":"petiole_sections!(petiole_node, petiole_nb_segments, unique_mtg_id)\n\nCreate the sections of a petiole.\n\nArguments\n\npetiole_node: the MTG Node of the petiole\npetiole_nb_segments: the number of segments used to discretize the petiole\nunique_mtg_id: a next free unique id for the MTG nodes, given as a Ref{Int}\n\nReturns\n\nNothing, the petiole node is updated in-place with its sections.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.petiole_width-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.petiole_width","text":"petiole_width(relative_position, width_cpoint, width_base)\n\nCompute the width profile along the petiole (m).\n\nArguments\n\nrelative_position: Position along the petiole (0-1) \nwidth_base: Width at base of leaf\nwidth_cpoint: Width of the leaf at C point\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.phyllotactic_angle-Tuple{Any, Any}","page":"Home","title":"VPalm.phyllotactic_angle","text":"phyllotactic_angle(phyllotactic_angle_mean, phyllotactic_angle_sd; rng=Random.MersenneTwister(1234))\n\nComputes the phyllotactic angle (°) using an average angle and a standard deviation (random draw from a normal distribution).\n\nArguments\n\nphyllotactic_angle_mean: The average phyllotactic angle (°).\nphyllotactic_angle_sd: The standard deviation of the phyllotactic angle (°).\n\nOptional arguments\n\nrng: The random number generator.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.piecewise_linear_area-Tuple{Any, Any}","page":"Home","title":"VPalm.piecewise_linear_area","text":"piecewise_linear_area(x, y)\n\nCalculate the area under a piecewise linear function. Equivalent to PiecewiseFunctionArea in the Java version.\n\nArguments\n\nx: Array of x-coordinates of the control points.\ny: Array of y-coordinates of the control points.\n\nReturns\n\nArea under the piecewise linear function.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.plane-Tuple{}","page":"Home","title":"VPalm.plane","text":"create_plane_mesh()\n\nCreate a simple rectangular plane mesh that will be used as a reference for leaflet segments. The plane is created in the XZ plane with width along X and length along Z.\n\nReturns\n\nA Meshes.SimpleMesh object representing a simple rectangular plane mesh\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.properties_petiole_section-NTuple{9, Any}","page":"Home","title":"VPalm.properties_petiole_section","text":"properties_petiole_section(\n    index, nb_sections, width_base, height_base,\n    width_cpoint, height_cpoint, petiole_section_length,\n    petiole_insertion_angle, petiole_section_insertion_angle,\n    azimuthal_angle\n)\n\nCompute the properties of each section of the petiole.\n\nArguments\n\nindex: The index of the section within all sections (1-nb_sections)\nnb_sections: The number of sections discretizing the petiole\nwidth_base: Width of the petiole at its base (m)\nheigth_base: Height of the petiole at its base (m)\nwidth_cpoint: Width of the petiole at the C point (tip of the petiole, i.e. transition point to rachis, m)\nheight_cpoint: Height at the C point (m)\npetiole_section_length: The length of the petiole sections (m)\npetiole_insertion_angle: Zenithal angle of insertion between the petiole and the stipe (local angle, relative to the stipe, °)\npetiole_section_insertion_angle: The zenithal angle of insertion between the petioles sections (°)\nazimuthal_angle: Azimuthal angle at the insertion (°)\n\nReturns\n\nA vector of dimensions for each section, given as a named tuple:\n\nwidth: width of the section (m)\nheight: height of the section (m)\nlength: length of the section (m)\nzenithal_angle: zenithal angle of the section (global angle, °)\nazimuthal_angle: azimuthal angle of the section (global angle, °)\ntorsion_angle: torsion angle of the section (°)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.rachis_expansion-Tuple{Any, Any}","page":"Home","title":"VPalm.rachis_expansion","text":"rachis_expansion(leaf_rank, rachis_final_length)\n\nSimple function to compute the rachis expansion (using an expansion factor)\n    based on the leaf rank.\n\n# Arguments\n\n- `leaf_rank`: The rank of the leaf.\n- `rachis_final_length`: The final length of the rachis.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.rachis_height-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.rachis_height","text":"rachis_height(relative_position, cpoint_height, rachis_height_tappering)\n\nComputes the rachis height (m) at a given relative position using a the height at C Point and rachis tappering.\n\nArguments\n\nrelative_position: The relative position along the rachis (0: base to 1: tip).\ncpoint_height: The height of the rachis at the C point, i.e. rachis base (m).\nrachis_height_tappering: The tappering factor for the rachis height.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.rachis_width-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.rachis_width","text":"rachis_width(relative_position, cpoint_width, rachis_width_tip)\n\nComputes the rachis width (m) at a given relative position using the width at C Point and rachis width at the tip.\n\nArguments\n\nrelative_position: The relative position along the rachis (0: base to 1: tip).\ncpoint_width: The width of the rachis at the C point, i.e. rachis base (m).\nrachis_width_tip: The width of the rachis at the tip (m).\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.read_parameters-Tuple{Any}","page":"Home","title":"VPalm.read_parameters","text":"read_parameters(file; verbose=true)\n\nReads a parameter file and returns the contents as an ordered dictionary.\n\nArguments\n\nfile: The path to the parameter file.\nverbose: Whether to show warnings for units (default: true)\n\nReturns\n\nAn ordered dictionary containing the contents of the parameter file with appropriate units.\n\nExample\n\nfile = joinpath(dirname(dirname(pathof(VPalm))),\"test\",\"files\",\"parameter_file.yml\")\nread_parameters(file)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.read_ply-Tuple{Any}","page":"Home","title":"VPalm.read_ply","text":"read_ply(fname)\n\nReads a PLY file and returns a Meshes.SimpleMesh object.\n\nArguments\n\nfname: The path to the PLY file.\n\nReturns\n\nA Meshes.SimpleMesh object.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.relative_leaflet_length-NTuple{4, Any}","page":"Home","title":"VPalm.relative_leaflet_length","text":"relative_leaflet_length(x, relative_length_first_leaflet, relative_length_last_leaflet, relative_position_leaflet_max_length)\n\nRelative leaflet length given by their relative position along the rachis.\n\nArguments\n\nx: relative leaflet position on the rachis (0: base to 1: tip)\nrelative_length_first_leaflet: relative length of the first leaflet on the rachis (0 to 1)\nrelative_length_last_leaflet: relative length of the last leaflet on the rachis  (0 to 1)\nrelative_position_leaflet_max_length: relative position of the longest leaflet on the rachis (0.111 to 0.999)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.relative_leaflet_position-Tuple{Any, Any}","page":"Home","title":"VPalm.relative_leaflet_position","text":"relative_leaflet_position(relative_rank, shape_coefficient)\n\nCompute the relative leaflet position on the rachis.\n\nArguments\n\nrelative_rank: Relative leaflet rank, usually in the form of (0 to 1].\nshape_coefficient: Shape coefficient (around 0).\n\nReturns\n\nThe relative leaflet position, in the same form as relative_rank, usually (0 to 1].\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.relative_leaflet_width-NTuple{4, Any}","page":"Home","title":"VPalm.relative_leaflet_width","text":"relative_leaflet_width(x, width_first, width_last, pos_width_max)\n\nCalculate the relative leaflet width at a given position along the rachis.\n\nArguments\n\nx: Relative position of the leaflet on the rachis [0 to 1].\nwidth_first: Relative width of the first leaflet (at rachis base).\nwidth_last: Relative width of the last leaflet (at rachis tip).\npos_width_max: Relative position where leaflets reach maximum width [0 to 1].\n\nDetails\n\nThis function uses a piecewise linear model to calculate relative leaflet width:\n\nFrom base to maximum width position: Linear increase from width_first to 1.0\nFrom maximum width position to tip: Linear decrease from 1.0 to width_last\n\nBiological Context\n\nThe width of leaflets along a palm frond typically follows a pattern where:\n\nLeaflets start relatively narrow at the base\nWiden to reach maximum width at some point along the rachis\nNarrow again toward the tip\n\nReturns\n\nThe relative width at position x [0 to 1].\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.shrink_leaflets_in_groups!","page":"Home","title":"VPalm.shrink_leaflets_in_groups!","text":"shrink_leaflets_in_groups!(positions, leaflets, ratio=2.0)\n\nAdjust the spacing between leaflets to create appropriate within-group and between-group distances.\n\nArguments\n\npositions: Vector of current leaflet positions along the rachis.\nleaflets: A NamedTuple containing arrays for leaflet properties (group, group_size, plane).\nratio=2.0: Ratio of inter-group to intra-group spacing.\n\nDetails\n\nThis function implements a biological principle where leaflets within the same group are positioned closer together than leaflets in different groups. It:\n\nUses a fixed ratio (2:1) between inter-group and intra-group spacing\nPreserves the overall distribution pattern while creating distinct groups\nProcesses each group sequentially, adjusting positions based on group size\n\nBiological Context\n\nIn many palm species, particularly oil palm, leaflets appear in distinct groups along the rachis. This grouping pattern is characterized by:\n\nConsistent, smaller spacing between leaflets within the same group\nLarger spacing between adjacent groups\nThe ratio between these spacings is typically species-specific\n\nThis spacing pattern is essential for the palm's characteristic appearance and  affects light interception patterns along the frond.\n\n\n\n\n\n","category":"function"},{"location":"#VPalm.snag-Tuple{}","page":"Home","title":"VPalm.snag","text":"snag()\nsnag(l, w, h)\n\nReturns a normalized snag mesh, or a snag mesh with given dimensions in m.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.stem_bending-Tuple{Any, Any}","page":"Home","title":"VPalm.stem_bending","text":"stem_bending(stem_bending_mean, stem_bending_sd; rng=Random.MersenneTwister(1234))\n\nComputes the stem bending (°) using an average bending and a standard deviation (random draw from a normal distribution).\n\nArguments\n\nstem_bending_mean: The average stem bending (°).\nstem_bending_sd: The standard deviation of the stem bending (°).\n\nOptional arguments\n\nrng: The random number generator.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.stem_diameter-NTuple{6, Any}","page":"Home","title":"VPalm.stem_diameter","text":"stem_diameter(rachis_length_reference, stem_diameter_max, stem_diameter_slope, stem_diameter_inflection, stem_diameter_residual)\n\nComputes the stem diameter (m) at a given rachis length reference (m).\n\nArguments\n\nrachis_length_reference: The rachis length reference (m). Taken as the rachis length of the first leaf.\nstem_diameter_max: The maximum stem diameter (m).\nstem_diameter_slope: The slope of the logistic function.\nstem_diameter_inflection: The inflection point of the logistic function.\nstem_diameter_residual: The residual of the stem diameter (m).\nstem_diameter_snag: The diameter estimation due to snags (m).\n\nOptional arguments\n\nrng: The random number generator.\n\nDetails\n\nThe stem diameter is computed using a logistic function, and then some variability is added to simulate natural variations that might occur in real-world scenarios.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.stem_height-NTuple{6, Any}","page":"Home","title":"VPalm.stem_height","text":"stem_height(nb_leaves_emitted, initial_stem_height, stem_height_coefficient, internode_length_at_maturity, stem_growth_start)\n\nComputes the stem height (m) at a given number of leaves emitted.\n\nArguments\n\nnb_leaves_emitted: The number of leaves emitted from planting.\ninitial_stem_height: The initial stem height at planting (m).\nstem_height_coefficient: The coefficient of the exponential function.\ninternode_length_at_maturity: The internode length when the plant is mature (m).\nstem_growth_start: The number of leaves emitted at which the stem starts to grow (m). This is because the stem does not grow at the same rate at the beginning of the plant's life,\n\nbecause it first grows more in diameter than in height.\n\nstem_height_variation: The variation of the stem height (m) due to the random draw from a normal distribution.\n\nOptional arguments\n\nrng: The random number generator.\n\nDetails\n\nThe stem height is computed using an exponential function for the first stem_growth_start leaves emitted, and then a linear function for the remaining leaves emitted.\n\nNote that the stem height can also be subject to some variability using stem_height_variation, simulating natural variations that might occur in real-world scenarios, but this variability will never make the stem height go below 30% of the intial computed height.\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.unbend-Tuple{Any, Any}","page":"Home","title":"VPalm.unbend","text":"unbend(distance, inclination)\n\nRemoves torsion and bending of a bent beam by transforming it into a straight line, while preserving its insertion angle (inclination angle of the first segment).\n\nArguments\n\ndistance: Vector of distances between consecutive points (in meters)\ninclination: Vector of inclination angles (in degrees), only the first value is used\n\nReturns\n\nA vector of Meshes.Point objects representing the unbent positions\n\nDetails\n\nThis function creates a straight line with the same cumulative length as the input distances, while maintaining the insertion angle specified by the first inclination value. The output points represent the unbent state of a curved structure.\n\nNote\n\nMainly used to compute the input coordinates for bend() from experimental points.\n\nExample\n\nusing VPalm, Unitful, Meshes\ndistances = [0.001, 1.340, 1.340, 0.770, 0.770]u\"m\";\ninclinations = [48.8, 48.8, 48.8, 48.8, 48.8];  # degrees\npoints = VPalm.unbend(distances, inclinations)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.width_at_cpoint-Tuple{Any, Any, Any}","page":"Home","title":"VPalm.width_at_cpoint","text":"width_at_cpoint(rachis_length, cpoint_width_intercept, cpoint_width_slope)\n\nCompute width at C point based on rachis length.\n\nArguments\n\nrachis_length: Length of rachis (m)\ncpoint_width_intercept: Intercept of linear function (m)\ncpoint_width_slope: Slope of linear function\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.write_parameters-Tuple{Any, Any}","page":"Home","title":"VPalm.write_parameters","text":"write_parameters(file, params)\n\nWrite the given parameters to a file using YAML format.\n\nArguments\n\nfile: The file path to write the parameters to.\nparams: The parameters to be written.\n\nExample\n\nfile = joinpath(dirname(dirname(pathof(VPalm))),\"test\",\"files\",\"parameter_file.yml\")\nparams = read_parameters(file)\nwrite_parameters(tempname(), params)\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.xyz_to_dist_and_angles-Union{Tuple{AbstractVector{P}}, Tuple{P}} where P<:Meshes.Point","page":"Home","title":"VPalm.xyz_to_dist_and_angles","text":"xyz_to_dist_and_angles(points)\n\nCompute segment lengths and angles from point coordinates.\n\nArguments\n\npoints: A vector of Meshes.Points.\n\nReturns\n\nA NamedTuple with fields:\ndist_p2p1: Vector of segment lengths (m).\nvangle_xy: Vector of angles between the segment and the XY plane (radians).\nvangle_xz: Vector of angles between the segment and the XZ plane (radians).\n\n\n\n\n\n","category":"method"},{"location":"#VPalm.@check_unit","page":"Home","title":"VPalm.@check_unit","text":"@check_unit(variable, expected_unit, [verbose=true])\n\nCheck if a variable has the expected unit type. If no unit is found, assign the expected unit. If a different unit is found, try to convert to the expected unit.\n\nArguments\n\nvariable: The variable to check\nexpected_unit: The expected unit (e.g., u\"m\")\nverbose: Whether to show warnings (default: true)\n\nExamples\n\n```julia rachislength = 10 @checkunit rachis_length u\"m\"  # Will add u\"m\" and warn\n\npetiolelength = 10 @checkunit petiole_length u\"m\" false # Will add u\"m\" without a warning\n\nmass = 5.0u\"g\" @check_unit mass u\"kg\"   # Will convert g to kg\n\n\n\n\n\n","category":"macro"}]
}
